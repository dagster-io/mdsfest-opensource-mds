import time
import zipfile
from tempfile import NamedTemporaryFile
from typing import List, Tuple
from dataclasses import dataclass
from pathlib import Path

import requests
import dagster as dg
from dagster.components import Component, ComponentLoadContext, Resolvable


# Moved download_and_extract_data here from assets.py
def _download_and_extract_data(
    context: dg.AssetExecutionContext, url: str, component_directory: Path
) -> Tuple[List[str], float]:
    """Downloads a zip file from a URL and extracts its contents."""
    extract_path = component_directory / "data" / "raw" / "checklist_data"
    extract_path.mkdir(parents=True, exist_ok=True)
    with NamedTemporaryFile(suffix=".zip") as f:
        start_time = time.time()
        context.log.info(f"Downloading checklist data from {url}")
        r = requests.get(url)
        context.log.info(f"Downloaded {len(r.content)} bytes")
        f.write(r.content)
        f.seek(0)

        with zipfile.ZipFile(f.name, "r") as zip_ref:
            extracted_names = zip_ref.namelist()
            zip_ref.extractall(extract_path)
            end_time = time.time()
            context.log.info(f"Extracted checklist data to {extract_path}")

        return extracted_names, end_time - start_time


@dataclass
class DataDownloader(Component, Resolvable):
    """Downloads data from a specified URL and makes it available as a Dagster asset.

    Attributes:
        name (str): The name to assign to the generated Dagster asset.
        url (str): The URL from which to download the data (must be a zip file).
        description (str): Optional description of the data being downloaded.
    """

    name: str
    url: str
    description: str = ""

    def build_defs(self, context: ComponentLoadContext) -> dg.Definitions:
        # Resolve the path relative to the component definition file
        # Note: This assumes the component definition lives within the standard project structure
        # generated by `dg scaffold`
        component_directory = Path(context.path).parent.parent.parent

        @dg.asset(name=self.name, compute_kind="python", group_name="raw_data")
        def _asset(context: dg.AssetExecutionContext):
            extracted_names, elapsed_time = self.execute(context, component_directory)
            context.add_output_metadata(
                metadata={
                    "names": extracted_names,
                    "num_files": len(extracted_names),
                    "elapsed_time": elapsed_time,
                    "source_url": self.url,
                    "description": self.description,
                },
            )

        return dg.Definitions(assets=[_asset])

    def execute(
        self, context: dg.AssetExecutionContext, component_directory: Path
    ) -> Tuple[List[str], float]:
        """Executes the download and extraction process."""
        return _download_and_extract_data(context, self.url, component_directory)


# Keep the old name for backward compatibility
BirdChecklist = DataDownloader
